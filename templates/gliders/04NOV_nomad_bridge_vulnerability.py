from glider import *


def query():
    """
    @title: Nomad-like unverified message processing draining tokens
    @description:
        Detects ERC20 token transfers executed in public/external functions where
        transfer amount or recipient are globally controllable (msg/tx/user inputs)
        and there is no evidence of preceding proof/verification calls (e.g., verify, prove,
        checkMembership) in the same function. Mirrors the Nomad Replica.process bug where
        verification was bypassed, enabling arbitrary withdrawals.

        A hit requires:
        - Calls ERC20 transfer/transferFrom functions
        - No preceding verification calls (verify, prove, checkMembership, etc.)
        - Not protected by access controls or reentrancy guards
    @tags: bridge, verification-bypass, access-control, token-drain, optimistic, cross-chain
    @author: pxng0lin | CAGED 2025
    @references: https://immunebytes.com/blog/nomad-bridge-exploit-aug-1-2022-detailed-analysis/
    """

    LIMIT_FUNCS = 1000

    def low(x):
        return (x or "").lower()

    def has_unchecked_token_transfers(fn):
        """Check for ERC20 transfer calls without verification, with msg-controlled recipients and contract balance transfers"""
        # Stage 1: Locate ERC20 transfer/transferFrom calls (exclude internal helpers)
        candidate_calls = (
            fn.callee_functions()
            .with_name_regex(r"^(transfer|transferFrom)$")
            .exec()
        )

        transfer_calls = [
            call for call in candidate_calls
            if call
            and call.get_contract()
            and fn.get_contract()
            and call.get_contract().address != fn.get_contract().address
        ]

        if not transfer_calls:
            return False

        # Stage 2: Check for verification calls (early exit if verified)
        verify_instructions = fn.instructions().with_one_of_callee_names([
            'verify', 'verifyproof', 'verifymembership', 'checkmembership',
            'prove', 'proveandprocess', 'authenticate', 'isvalid', 'isverified', 'accept'
        ], sensitivity=False).exec()

        if verify_instructions:
            return False  # Has verification

        # Stage 3: Check if transfers have msg-controlled recipients and originate from contract balance
        has_msg_controlled_recipient = False
        has_contract_balance_transfer = False

        # Analyze transfer instructions for recipient control and balance source
        transfer_instructions = fn.instructions().with_one_of_callee_names(['transfer', 'transferFrom'], sensitivity=False).exec()

        for ins in transfer_instructions:
            if ins and ins.get_components:
                components = ins.get_components().exec()
                for comp in components:
                    if comp and comp.name and low(comp.name) in ['transfer', 'transferfrom']:
                        # Check if recipient is msg-controlled (msg.sender or similar)
                        args = ins.get_value().get_args() if ins.get_value() else []
                        if len(args) >= 2:  # transfer(recipient, amount) or transferFrom(from, to, amount)
                            recipient_arg = args[1] if len(args) == 3 else args[0]  # to address
                            if recipient_arg and 'msg.sender' in str(recipient_arg):
                                has_msg_controlled_recipient = True

                        # Check if transfer originates from contract balance (no explicit from address or from=address(this))
                        if len(args) == 2:  # transfer(recipient, amount) - assumes from contract
                            has_contract_balance_transfer = True
                        elif len(args) == 3:  # transferFrom(from, to, amount)
                            from_arg = args[0]
                            if from_arg and ('address(this)' in str(from_arg) or 'this.address' in str(from_arg)):
                                has_contract_balance_transfer = True

        # Require both msg-controlled recipient and contract balance transfer (mirroring Nomad behavior)
        if not (has_msg_controlled_recipient and has_contract_balance_transfer):
            return False

        return True

    def has_bridge_context(fn):
        """Check if function has bridge/cross-chain context indicators - tightened to require handler verbs"""
        sig_lc = low(fn.signature() or '')

        # Handler-like function names (require these, not just bytes arguments)
        handler_hints = ['process', 'processmessage', 'execute', 'executemessage', 'handle', 'relay', 'proveandprocess']
        if any(h in sig_lc for h in handler_hints):
            return True

        return False

    def lacks_access_controls(fn):
        """Check if function lacks basic access controls"""
        # Check for common access control modifiers
        modifiers = fn.modifiers().exec()
        mod_names = [low(m.name or '') for m in modifiers if m.name]

        # Has access controls if any of these modifiers are present
        access_controls = ['onlyowner', 'onlyadmin', 'onlyauthorized', 'onlycontroller', 'accesscontrol']
        if any(control in ' '.join(mod_names) for control in access_controls):
            return False

        return True

    # API-first filtering: unverified transfers in bridge context without access controls
    vulnerable_funcs = (
        Functions()
        .with_one_property([MethodProp.PUBLIC, MethodProp.EXTERNAL])
        .without_properties([MethodProp.IS_CONSTRUCTOR, MethodProp.IS_VIEW, MethodProp.IS_PURE])
        .exec(LIMIT_FUNCS)
        .filter(has_unchecked_token_transfers)    # Unchecked ERC20 transfers without verification
        .filter(has_bridge_context)               # Bridge/cross-chain context
        .filter(lacks_access_controls)            # No access controls
    )

    return vulnerable_funcs
